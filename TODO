BEFORE REDIS 1.0.0-rc1

- Update the FAQ with max number of keys in a DB and the overcommit thing
- Add number of keys for every DB in INFO
- maxmemory support in config file.
- Resize the expires hash tables if needed as well
- TTL command that returns -1 if a key is not volatile otherwise the time to live of a volatile key.
- Remove max number of args limit
- What happens if the saving child gets killed or segfaults instead of ending normally? Handle this.
- Make sinterstore / unionstore / sdiffstore returning the cardinality of the resulting set.
- maxclients directive
- check 'server.dirty' everywere
- Shutdown must kill other background savings before to start saving. Otherwise the DB can get replaced by the child that rename(2) after the parent for some reason. Child should trap the signal and remove the temp file name.
- Document replication
- Objects sharing configuration, add the directive "objectsharingpool <size>"
- Make sure to convert all the fstat() calls to 64bit versions.
- SINTERCOUNT, SUNIONCOUNT, SDIFFCOUNT

AFTER 1.0 stable release

- Use partial qsort for SORT + LIMIT. Don't copy the list into a vector when BY argument is constant.
- Locking primitives
- MDEL (or vararg DEL)
- Write the hash table size of every db in the dump, so that Redis can resize the hash table just one time when loading a big DB.
- Elapsed time in logs for SAVE when saving is going to take more than 2 seconds
- replication automated tests

FUTURE HINTS

- In memory compression: if in-memory values compression will be implemented, make sure to implement this so that addReply() is able to handle compressed objects, just creating an uncompressed version on the fly and adding this to the output queue instead of the original one. When insetad we need to look at the object string value (SORT BY for example), call a function that will turn the object into an uncompresed one.
